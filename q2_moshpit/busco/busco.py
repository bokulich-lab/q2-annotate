# ----------------------------------------------------------------------------
# Copyright (c) 2023, QIIME 2 development team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file LICENSE, distributed with this software.
# ----------------------------------------------------------------------------


import os
import json
import tempfile
import pkg_resources
import q2templates
import seaborn as sns
import matplotlib.pyplot as plt
import pandas as pd
from copy import deepcopy
from distutils.dir_util import copy_tree
from .utils import _parse_busco_params, _draw_busco_plots_for_render
from .._utils import _process_common_input_params, run_command
from zipfile import ZipFile
from typing import List
from q2_types_genomics.per_sample_data._format import MultiMAGSequencesDirFmt


def _run_busco(
    output_dir: str, mags: MultiMAGSequencesDirFmt, params: List[str]
) -> dict:
    """Evaluates bins for all samples using BUSCO.

    Args:
        output_dir (str): Location where the final results should be stored.
        mags (MultiMAGSequencesDirFmt): The mags to be analyzed.
        params (List[str]): List of parsed arguments to pass to BUSCO.

    Returns:
        dict: Dictionary where keys are sample IDs and values are the paths
            to the `batch_summary.txt` generated by BUSCO, e.g.
            `tmp/busco_output/<sampl_id>/batch_summary.txt`.
    """

    # Define base command
    base_cmd = ["busco", *params]

    # Creates pandas df "manifest" from bins
    manifest: pd.DataFrame = mags.manifest.view(pd.DataFrame)

    # Make a new column in manifest with the directories of files listed in column "filename"
    manifest["sample_dir"] = manifest.filename.apply(lambda x: os.path.dirname(x))

    # numpy.ndarray with unique dirs
    sample_dirs = manifest["sample_dir"].unique()

    # Initialize dictionary with paths to run summeries
    path_to_run_summeries = {}

    # For every unique sample dir run busco
    for sample_dir in sample_dirs:
        # Get name of dir and make path with it inside the tmp dir
        # NOTE: It appears that the paths in filename column are <sample_id>/file_name.fasta
        # The created sample_dir column already contains the isolated <sample_id>.
        # Therefore the os.path.split(sample_dir)[-1] steps seeps unnecessary, unless
        # paths in filename column are some times compleate paths and not only relative.
        sample = os.path.split(sample_dir)[-1]

        # Deep copy base comand extend it with the sample specific info and run it
        cmd = deepcopy(base_cmd)
        cmd.extend(["--in", sample_dir, "--out_path", output_dir, "-o", sample])
        run_command(cmd, env={**os.environ})

        # Check for output
        path_to_run_summerie = os.path.join(output_dir, sample, "batch_summary.txt")
        if os.path.isfile(path_to_run_summerie):
            path_to_run_summeries[sample] = path_to_run_summerie
        else:
            raise FileNotFoundError(
                f"BUSCO batch summary file {path_to_run_summerie} not found."
            )

    # Return a dict where key is sample name and value is path "tmp/sample/batch_summary.txt"
    return path_to_run_summeries


def _draw_busco_plots(path_to_run_summeries: dict, output_dir: str) -> dict:
    """
    Generates plots for all `batch_summary.txt` (one for every sample) and saves
    them to `output_dir`.

    Args:
        output_dir (str): Location where the final results should be stored.
        mags (MultiMAGSequencesDirFmt): The mags to be analyzed.
        params (List[str]): List of parsed arguments to pass to BUSCO

    Returns:
        dict: Dictionary where keys are sample IDs and values are the paths
            to the generated plots, e.g. `tmp/plots/<sampl_id>/plot_batch_summary.svg`.
    """

    # Initialize output dictionary
    paths_to_plots = {}

    # For every sample make a plot
    for sample_id, path_to_summary in path_to_run_summeries:
        # Read in text file as dataframe
        df = pd.read_csv(filepath_or_buffer=path_to_summary, sep="\t")

        # Compute cumulative percentages
        df["single"] = df["Single"]
        df["duplicated"] = df["Single"] + df["Duplicated"]
        df["fragmented"] = df["duplicated"] + df["Fragmented"]
        df["missing"] = df["fragmented"] + df["Missing"]

        # Get sample id without extension (.fasta)
        df["input_file"] = df["Input file"].str.split(".", expand=True)[0]

        # Set the style
        sns.set(style="whitegrid")
        sns.set_palette("colorblind")

        # Create a horizontal stacked barplot
        plt.figure(figsize=(10, 6))
        sns.barplot(data=df, y="input_file", x="missing", color="r", label="Missing")
        sns.barplot(
            data=df,
            y="input_file",
            x="fragmented",
            color="tab:orange",
            label="Fragmented",
        )
        sns.barplot(
            data=df,
            y="input_file",
            x="duplicated",
            color="tab:cyan",
            label="Duplicated",
        )
        sns.barplot(
            data=df, y="input_file", x="single", color="tab:blue", label="Single"
        )

        # Customize the plot
        plt.xlabel("%BUSCO")
        plt.ylabel("MAG ID's")
        plt.legend(loc="lower right")
        plt.title(f"Sample ID: {sample_id}")

        # Save figure to file
        output_name = os.path.join(output_dir, sample_id, "plot_batch_summary.svg")
        plt.savefig(output_name, format="svg")

        # Save path to dictionary
        paths_to_plots[sample_id] = output_name

    # Return paths to all generated plots
    return paths_to_plots


def _zip_busco_plots(paths_to_plots: dict, zip_path: str) -> None:
    """
    Creates a single zip archive containing all plots produced by CheckM
    for all the samples.

    Args:
        plots_per_sample (Mapping[str, Mapping[str, str]]): Dictionary
            containing the mapping of plot paths per plot type per sample.
        zip_path (str): The path to the zip archive.
    """

    # Get shortest coommon path between files
    common_path = os.path.commonpath(paths_to_plots.values())

    # Write to zipfile
    with ZipFile(zip_path, "w") as zf:
        for _, path_to_plot in paths_to_plots.items():
            arcname = os.path.relpath(path_to_plot, common_path)
            zf.write(path_to_plot, arcname=arcname)


def busco(
    output_dir: str,
    mags: MultiMAGSequencesDirFmt,
    mode: str = None,
    lineage: str = None,
    augustus: bool = None,
    augustus_parameters: str = None,
    augustus_species: str = None,
    auto_lineage: bool = None,
    auto_lineage_euk: bool = None,
    auto_lineage_prok: bool = None,
    cpu: int = None,
    config: str = None,
    contig_break: int = None,
    datasets_version: str = None,
    download: str = None,
    download_base_url: str = None,
    download_path: str = None,
    e_value: float = None,
    force: bool = None,
    limit: int = None,
    help: bool = None,
    list_datasets: bool = None,
    long: bool = None,
    metaeuk_parameters: str = None,
    metaeuk_rerun_parameters: str = None,
    offline: bool = None,
    quiet: bool = None,
    restart: bool = None,
    scaffold_composition: bool = None,
    tar: bool = None,
    update_data: bool = None,
    version: bool = None,
) -> None:
    """
    qiime2 vizualization for the BUSCO assessment tool <https://busco.ezlab.org/>.

    Args:
        see all possible inputs by running `qiime moshpit plot_busco`

    Output:
        plots.zip: zip file containing all of the busco plots
        busco_output: all busco outputfiles
        qiime_html: html for rendering the output plots
    """

    # Create dictionary with local varaibles (kwards passed to the function or their defaults)
    # excluding "output_dir" and "mags"
    kwargs = {k: v for k, v in locals().items() if k not in ["output_dir", "mags"]}

    # Filter out all kwards that are None, False or 0.0
    common_args = _process_common_input_params(
        processing_func=_parse_busco_params, params=kwargs
    )

    # Creates output directory with path 'tmp'
    with tempfile.TemporaryDirectory() as tmp:
        # Run busco for every sample. Returns dictionary to report files.
        results_dir = os.path.join(tmp, "busco_output")
        path_to_run_summeries = _run_busco(
            output_dir=results_dir, mags=mags, params=common_args
        )

        # Collect result for each sample and save to file.
        all_summeries_list = []
        for sample_id, path_to_summary in path_to_run_summeries.items():
            df = pd.read_csv(filepath_or_buffer=path_to_summary, sep="\t")
            df["sample_id"] = sample_id
            all_summeries_list.append[df]

        ## Concatenate
        all_summeries_df = pd.concat(all_summeries_list)

        ## Save to file
        all_summeries_path = os.path.join(tmp, "all_batch_cummeries.csv")
        all_summeries_df.to_csv(all_summeries_path)

        # Draw BUSCO plots for all samples
        plots_dir = os.path.join(tmp, "plots")
        paths_to_plots = _draw_busco_plots(
            path_to_run_summeries=path_to_run_summeries, output_dir=plots_dir
        )

        # Zip graphs for user download
        zip_name = os.path.join(tmp, "busco_plots.zip")
        _zip_busco_plots(paths_to_plots=paths_to_plots, zip_path=zip_name)

        # Render qiime html report
        ## Prepare context for jinja2 template
        context = {
            "tabs": [{"title": "BUSCO Results", "url": "index.html"}],
            "samples": json.dumps(list(path_to_run_summeries.keys())),
            "vega_plots": _draw_busco_plots_for_render(all_summeries_df),
        }

        # Copy BUSCO results from tmp dir to output_dir
        TEMPLATES = pkg_resources.resource_filename("q2_moshpit", "assets")
        index = os.path.join(TEMPLATES, "busco", "index.html")
        copy_tree(os.path.join(TEMPLATES, "busco"), output_dir)
        copy_tree(plots_dir, os.path.join(output_dir, "plots"))

        # Render
        templates = [index]
        q2templates.render(templates, output_dir, context=context)

        # Remove unwanted files
        # until Bootstrap 3 is replaced with v5, remove the v3 scripts as
        # the HTML files are adjusted to work with v5
        os.remove(
            os.path.join(output_dir, "q2templateassets", "css", "bootstrap.min.css")
        )
        os.remove(
            os.path.join(output_dir, "q2templateassets", "js", "bootstrap.min.js")
        )

        # NOTE: It seems to me that the plots are saved to a zip in out_dir but, not everything is zipped.
        # Isnt it supposed to?
